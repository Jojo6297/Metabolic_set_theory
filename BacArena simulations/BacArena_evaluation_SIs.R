
# This script supplements the manuscript "Leveraging agent-based modeling and co-occurrence data to
# validate a generalized metabolic model of species interaction in the human gut microbiome" by 
# Jyoti Jyoti, Hannah Zoller, Wolfgang zu Castell, and Marc-Thorsten HÃ¼tt.

# This script takes as input
# - the simulation output files "simulations_random_set_[]_repetition_[].Rdata" 
# (as being generated by BacArena_simulation.R)
# - the synergistic network-based indices of all pairs of species (sorted by random sets in the folders "random_set_SIs_[]")

# This script produces 
# - the csv files "Correlations_means/sds_shared/cross_feeding_SIs.csv"

# Written by Hannah Zoller, 2025


#Set working directory

work_folder <- "work_folder"
setwd(work_folder)

#Load packages

library(xlsx)
library(stringr)
library(BacArena)
library(matrixStats)
library(ggplot2)
library(Hmisc)
library(ppcor)

#Create vector to store averaged correlations between cross-feeding/shared feeding and indices

results_all_cross <- rep(NA,21)
results_all_share <- rep(NA,21)

#Create matrix to store correlations between cross-feeding and shared feeding

cross_share_c <- matrix(NA,10,10)
cross_share_p <- matrix(NA,10,10)


for(set_nr in 1:10){ 
  
  #Determine number of species
  
  names <- list.files(paste("/random_set_models_",set_nr,sep=""), full.names = FALSE)
  nb <- length(names)
  
  #Correlations
  
  richness <- c(0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9)
  
  fracs_all <- list() #list containing results for all 10 repetitions
  
  for(reps in 1:10){
    
    sim_reps <- get(load(paste("simulations_random_set_",set_nr,"_repetition_",reps,".Rdata", sep = "")))
    
    fracs <- list()
    
    for(rn in 1:10){
      
      fracs_matrix_list <- list()
      
      res <- sim_reps[[rn+(f-1)*10]]
      fracs_matrix_log <- matrix(NA,nb,nb)
      fracs_matrix <- matrix(NA,nb,nb)
      share_matrix_log <- matrix(NA,nb,nb)
      share_matrix <- matrix(NA,nb,nb)
      
      r <- 0
      for(a in 1:(nb-1)){
        for(b in (a+1):nb){
          
          r <- r+1
          
          res_tupel <- res[[r]]
          
          abund <- res[[r]][[8]]
          stop <- min(min(which(abund>=50)),10)
          stop <- stop-1 
          if(stop>=et){
            stop <- et
          }
          
          window <- c(2,stop)
          
          #total consumption per species
          
          sub <- res_tupel[[4]]
          flux <- res_tupel[[5]]
          time <- res_tupel[[6]]
          
          total_cons_log <- rep(NA,2)
          
          for(sp in 1:2){
            total_cons_log[sp] <- sum(log(1+abs(flux[[sp]][which(time[[sp]] %in% window[1]:stop)])), na.rm = TRUE)
            }
          
          #crossfeeding per species
          
          sub <- res_tupel[[1]]
          flux <- res_tupel[[2]]
          time <- res_tupel[[3]]
          
          total_cross_log <- rep(NA,2)
          
          for(sp in 1:2){
            if(length(flux[[sp]])>0){
              if(length(flux[[sp]][which(time[[sp]] %in% 2:stop)])>0){
                total_cross_log[sp] <- sum(log(1+abs(flux[[sp]][which(time[[sp]] %in% window[1]:stop)])), na.rm = TRUE)
                }else{
                total_cross_log[sp] <- 0
              }
            }else{
              total_cross_log[sp] <- 0
            }
          }
          
          #intersection of consumption per species
          
          sub <- res_tupel[[4]]
          flux <- res_tupel[[5]]
          time <- res_tupel[[6]]
          
          total_share_log <- rep(0,2)
          
          for(t in window[1]:stop){
            share <- intersect(sub[[1]][which(time[[1]] == t)],sub[[2]][which(time[[2]] == t)])
            for(sp in 1:2){
              if(length(share)>0){
                total_share_log[sp] <- total_share_log[sp] + sum(log(1+abs(flux[[sp]][intersect(which(time[[sp]]==t),which(sub[[sp]] %in% share))])))
               }
            }
          }
          
          #create fraction
          
          if(total_cons_log[1]>0){
            fracs_matrix_log[a,b] <- total_cross_log[1]/total_cons_log[1] #what a experiences by b
            share_matrix_log[a,b] <- total_share_log[1]/total_cons_log[1]
            
          }else{
            fracs_matrix_log[a,b] <- NA
            share_matrix_log[a,b] <- NA}
          
          if(total_cons_log[2]>0){
            
            fracs_matrix_log[b,a] <- total_cross_log[2]/total_cons_log[2] #what b experiences by a
            share_matrix_log[b,a] <- total_share_log[2]/total_cons_log[2]
            
          }else{
            fracs_matrix_log[b,a] <- NA
            share_matrix_log[b,a] <- NA}
          
        }
      }
      
      fracs_matrix_list[[1]] <- fracs_matrix_log
      
      fracs_matrix_list[[3]] <- share_matrix_log
      
      fracs[[rn]] <- fracs_matrix_list
      
    }
    
    fracs_all[[reps]] <- fracs
    
  }
  
  fracs <- list() #list containing averages of all 10 repetitions
  fracs_sd <- list() #list containing standard deviations across all 10 repetitions
  
  for(rn in 1:10){
    
    fracs[[rn]] <- list()
    fracs_sd[[rn]] <- list()
    for(le in 1:4){
      comp <- list()
      for(rep in 1:nr_reps){
        comp[[rep]] <- fracs_all[[rep]][[rn]][[le]]
      }
      fracs[[rn]][[le]] <-  apply(simplify2array(comp), 1:2, mean)
      fracs_sd[[rn]][[le]] <- apply(simplify2array(comp), 1:2, sd)
    
      }
    }
  
  dirs <- list.dirs(paste("random_set_SIs_",set_nr,sep=""), recursive = FALSE, full.names = FALSE)
  
  indices_means <- c()
  indices_sds <- c()
  indices_means_share <-   c()
  indices_sds_share <- c()
  indices_names <- c()
  indices_types <- c()
  indices_groups <- c()
  
  for(d in 1:length(dirs)){
    
    dirs_temp <- list.dirs(paste("/random_set_SIs_",set_nr,"/",dirs[d],sep=""))
   
    for(dt in 1:length(dirs_temp)){
      if(length(list.dirs(dirs_temp[dt]))==1){
        
        files <- list.files(dirs_temp[dt])
        files_long <- list.files(dirs_temp[dt], full.names = TRUE)
        
        corrs_all <- c()
        ps_all <- c()
        stars_all <- c()
        corrs_all_share <- c()
        ps_all_share <- c()
        stars_all_share <- c()
        
        fracs_all <- rep(NA,rn)
        
        for(li in 1:length(files)){
          
          #cross-feeding
          
          index_vector <- rep(NA,((choose(nb,2))*2))
          
          index_matrix <- read.csv(file = files_long[li])
          if(d!=4){
            index_matrix <- index_matrix[,-1] 
          }
          r <- 0
          for(i in 1:nb){
            for(j in 1:nb){
              if(i!=j){
                r <- r+1
                index_vector[r] <- index_matrix[i,j]
              }
            }
          }
          
          corrs_matrix <- matrix(NA,1,10)
          ps_matrix <- matrix(NA,1,10)
          
          corrs_matrix_share <- matrix(NA,1,10)
          ps_matrix_share <- matrix(NA,1,10)
          
          for(rn in 1:10){
            
            fracs_matrix <- fracs[[rn]][[l]]
            fracs_vector <- rep(NA,((choose(nb,2))*2))
            r <- 0
            for(i in 1:nb){
              for(j in 1:nb){
                if(i!=j){
                  r <- r+1
                  fracs_vector[r] <- fracs_matrix[i,j]
                }
              }
            }
            
            
            mc <- 0
            
            share_matrix <- fracs[[rn]][[l+2]]
            share_vector <- rep(NA,((choose(nb,2))*2))
            r <- 0
            for(i in 1:nb){
              for(j in 1:nb){
                if(i!=j){
                  r <- r+1
                  share_vector[r] <- share_matrix[i,j]
                }
              }
            }
            
            matrix_temp <- cbind(as.matrix(fracs_vector), as.matrix(share_vector), as.matrix(index_vector))
            matrix_temp <- na.omit(matrix_temp)
            fracs_vector_temp <- matrix_temp[,1]
            share_vector_temp <- matrix_temp[,2]
            index_vector_temp <- matrix_temp[,3]
                
            cor_sp <- cor.test(as.matrix(index_vector_temp),as.matrix(fracs_vector_temp),method = "spearman")
            cor_pear <- cor.test(as.matrix(index_vector_temp),as.matrix(fracs_vector_temp),method = "pearson")
            
            cor_sp_temp <- cor_sp
            cor_pear_temp <- cor_pear
            cor_sp <- rep(NA,2)
            cor_pear <- rep(NA,2)
            cor_sp[1] <- cor_sp_temp$estimate
            cor_sp[2] <- cor_sp_temp$p.value
            cor_pear[1] <- cor_pear_temp$estimate
            cor_pear[2] <- cor_pear_temp$p.value
            
            if(cor_sp[2]<=0.05 && cor_pear[2]<=0.05){
              if(cor_sp[1]*cor_pear[1]>0){
                mc <- which(abs(as.numeric(c(cor_sp[1],cor_pear[1])))==max(abs(as.numeric(c(cor_sp[1],cor_pear[1])))))
              }
            }
            
            if(mc>0){
              corrs_matrix[1,rn] <- as.numeric(c(cor_sp[1],cor_pear[1]))[mc]
              ps_matrix[1,rn] <- as.numeric(c(cor_sp[2],cor_pear[2]))[mc]
            }else{
              corrs_matrix[1,rn] <- 0
              ps_matrix[1,rn] <- 1
            }
            
            fracs_all[rn] <- mean(fracs_vector[which(fracs_vector>0)])
            
            #shared feeding
            
            mc <- 0

            cor_sp <- cor.test(as.matrix(index_vector_temp),as.matrix(share_vector_temp),method = "spearman")
            cor_pear <- cor.test(as.matrix(index_vector_temp),as.matrix(share_vector_temp),method = "pearson")
            
            cor_sp_temp <- cor_sp
            cor_pear_temp <- cor_pear
            cor_sp <- rep(NA,2)
            cor_pear <- rep(NA,2)
            cor_sp[1] <- cor_sp_temp$estimate
            cor_sp[2] <- cor_sp_temp$p.value
            cor_pear[1] <- cor_pear_temp$estimate
            cor_pear[2] <- cor_pear_temp$p.value
            
            if(cor_sp[2]<=0.05 && cor_pear[2]<=0.05){
              if(cor_sp[1]*cor_pear[1]>0){
                mc <- which(abs(as.numeric(c(cor_sp[1],cor_pear[1])))==max(abs(as.numeric(c(cor_sp[1],cor_pear[1])))))
              }
            }
            
            if(mc>0){
              corrs_matrix_share[1,rn] <- as.numeric(c(cor_sp[1],cor_pear[1]))[mc]
              ps_matrix_share[1,rn] <- as.numeric(c(cor_sp[2],cor_pear[2]))[mc]
            }else{
              corrs_matrix_share[1,rn] <- 0
              ps_matrix_share[1,rn] <- 1
            }
            
          }
          
          corrs_all <- c(corrs_all, corrs_matrix)
          ps_all <- c(ps_all, ps_matrix)
          
          corrs_all_share <- c(corrs_all_share, corrs_matrix_share)
          ps_all_share <- c(ps_all_share, ps_matrix_share)
          
        }
        
        #additional stuff for the paper plot
        
        indices <- list()
        indices[[1]] <- c(NA)
        indices[[2]] <- c(NA)
        indices[[3]] <- c(NA)
        indices[[4]] <- c(NA)
        
        for(li in 1:length(files)){
          file <- files[[li]]
          file_split = str_split(file, "_")
          for(j in 1:4){
            indices_temp <- indices[[j]]
            indices[[j]] <- c(indices_temp, file_split[[1]][[j]])
          }
        }
        
        for(j in 1:4){
          indices_temp <- indices[[j]]
          indices[[j]] <- indices_temp[-1]
        }
        
        corrs_all_vec <- matrix(corrs_all,length(files),10, byrow = TRUE)
        corrs_all_share_vec <- matrix(corrs_all_share,length(files),10, byrow=TRUE)
        
        types <- unique(indices[[3]]) 
        
        for(i in 1:length(types)){
          nos <- which(indices[[3]]==types[i])
          if(length(nos)>1){
            types_mean <- mean(colMeans(corrs_all_vec[nos,2:10])) 
            types_sd <- sd(colMeans(corrs_all_vec[nos,2:10])) 
            types_mean_share <- mean(colMeans(corrs_all_share_vec[nos,2:10])) 
            types_sd_share <- sd(colMeans(corrs_all_share_vec[nos,2:10])) 
          }else{
            types_mean <- mean(corrs_all_vec[nos,2:10])
            types_sd <- sd(corrs_all_vec[nos,2:10]) 
            types_mean_share <- mean(corrs_all_share_vec[nos,2:10]) 
            types_sd_share <- sd(corrs_all_share_vec[nos,2:10]) 
          }
          types_cisi <- indices[[2]][nos[1]]
          types_group <- indices[[1]][nos[1]]
          
          indices_means <- c(indices_means,types_mean)
          indices_sds <- c(indices_sds,types_sd)
          indices_means_share <- c(indices_means_share,types_mean_share)
          indices_sds_share <- c(indices_sds_share,types_sd_share)
          indices_names <- c(indices_names,types[i])
          indices_types <- c(indices_types, types_cisi)
          indices_groups <- c(indices_groups, types_group)
          
        }
        
      }
    }
    
  }
  
  full_names <- c()
  for(i in 1:length(indices_names)){
    name <- indices_names[i]
    group <- indices_groups[i]
    full_name <- paste(group,"_",name,sep="")
    full_names <- c(full_names,full_name)
  }
  
  cis1 <- intersect(which(indices_types == "CI"), which(indices_groups == "Borenstein"))
  cis2 <- intersect(which(indices_types == "CI"), which(indices_groups != "Borenstein"))
  sis1 <- intersect(which(indices_types == "SI"), which(indices_groups == "Borenstein"))
  sis2 <- intersect(which(indices_types == "SI"), which(indices_groups != "Borenstein"))
  
  cis <- c(cis1,cis2)
  sis <- c(sis1,sis2)
  indices_means <- indices_means[c(cis,sis)]
  indices_sds <- indices_sds[c(cis,sis)]
  indices_means_share <- indices_means_share[c(cis,sis)]
  indices_sds_share <- indices_sds_share[c(cis,sis)]
  indices_names <- indices_names[c(cis,sis)]
  indices_types <- indices_types[c(cis,sis)]
  indices_groups <- indices_groups[c(cis,sis)]
  full_names <- full_names[c(cis,sis)]
  
  indices_length <- length(indices_names) 
  
  indices_l <- 1:indices_length

  results <- list(indices_means, indices_sds, indices_means_share, indices_sds_share, full_names, indices_names, indices_groups, indices_types, indices_l)
  
  indices_length_plot <- length(results[[1]])
  
  results_all_cross <- rbind(results_all_cross, results[[1]])
  results_all_share <- rbind(results_all_share, results[[3]])
  
}

#Save correlations

results_all_cross <- results_all_cross[-1,]
results_all_share <- results_all_share[-1,]

names_indices <- results[[6]]

table <- as.matrix(colMeans(results_all_cross))

colnames(table) <- 0.03
rownames(table) <- names_indices

write.csv(table, file = "Correlations_means_cross_feeding_SIs.csv")


table <- as.matrix(colSds(results_all_cross))

colnames(table) <- 0.03
rownames(table) <- names_indices
write.csv(table, file = "Correlations_sds_cross_feeding_SIs.csv")


table <- as.matrix(colMeans(results_all_share))

colnames(table) <- 0.03
rownames(table) <- name_indices

write.csv(table, file = "Correlations_means_shared_feeding_SIs.csv")


table <- colSds(results_all_share)

table <- as.matrix(table[which(is.na(table)==FALSE)])

colnames(table) <- 0.03
rownames(table) <- names_indices

write.csv(table, file = "Correlations_sds_shared_feeding_SIs.csv")
